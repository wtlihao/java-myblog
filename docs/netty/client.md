## 客户端与服务端通信协议编解码

1、协议介绍：无论是使用 Netty 还是原始的 Socket 编程，基于 `TCP` 通信的数据包格式均为二进制，`协议`指的就是客户端与服务端事先商量好的，每一个二进制数据包中每一段字节分别代表什么含义的`规则`。

2、通信协议设计
![image](https://user-gold-cdn.xitu.io/2018/8/13/1653028b36ee5d81?imageslim)

3、上图解释：

* 第一个字段是`魔数`，通常情况下为固定的几个字节（我们这边规定为4个字节）。 为什么需要这个字段，而且还是一个固定的数？假设我们在服务器上开了一个端口，比如 80 端口，如果没有这个魔数，任何数据包传递到服务器，服务器都会根据自定义协议来进行处理，包括不符合自定义协议规范的数据包。例如，我们直接通过 http://服务器ip 来访问服务器（默认为 80 端口）， 服务端收到的是一个标准的 HTTP 协议数据包，但是它仍然会按照事先约定好的协议来处理 HTTP 协议，显然，这是会解析出错的。而有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。在 Java 的字节码的二进制文件中，开头的 4 个字节为0xcafebabe 用来标识这是个字节码文件，亦是异曲同工之妙。
* 接下来一个字节为`版本号`，通常情况下是`预留字段`，用于`协议升级`的时候用到，有点类似 TCP 协议中的一个字段标识是 IPV4 协议还是 IPV6 协议，大多数情况下，这个字段是用不到的。
* 第三部分，`序列化算法`表示如何把 Java 对象转换二进制数据以及二进制数据如何转换回 Java 对象，比如 `Java 自带的序列化`，`json`，`hessian` 等序列化方式。
* 第四部分的字段表示`指令`，服务端或者客户端每收到一种指令都会有相应的处理逻辑,用一个字节来表示，最高支持想2^8种指令。
* 接下来的字段为`数据长度`，占四个字节。
* 最后一个部分为`数据内容`，每一种指令对应的数据是不一样的


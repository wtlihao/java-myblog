## `JVM`

### 1、`JVM基本概念`:JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接的交互。

### 2、`内存模型`

1. `方法区`----存储类信息、静态变量
2. `虚拟机栈`----线程私有
3. `本地方法栈`----本地方法变量存储区
4. `堆`----对象存储区
5. `程序计数器`----控制程序执行顺序

### 3、`堆`

1. `新生代`----Eden区、S0、S1
2. `老年代`----大对象和S0、s1转移的对象
3. `持久代`----是方法区的实现，主要存放所有已加载的类信息，方法信息，常量池
4. `Tips`：面试官如果问这个数字，必须答出来。新生代占比:6:1:1，新生代和老年代比例为1:3

### 4、`GC`

1. `标记垃圾算法`：
    1. `引用计数法`----淘汰，原因是会出现相互依赖问题
    2. `可达性算法`----GC树
        1. `Root节点`：栈帧本地变量表引用对象、本地方法引用对象、方法区常量引用对象、方法区静态变量引用的对象（词语是不是很模糊，LZ也很模糊）
2. `回收算法`
    1. `标记-清除`----每个对象如果标记清除，GC时会被回收，缺点在于内存碎片较多，产生后果就是浪费空间
    2. `标记-整理`----把标记的对象转移到另一块一样的，空间换时间
    3. `分代回收`----根据不同区域特点设置不同策略回收，新生代采取标记整理，老年代采取标记清除
    4. `Tips`：面试官如果问为什么Java采取这个分而治之算法呢？可以这样回答：新生代转成老年代对象很快，内存空间较少，GC频率较多，所以在新生代有分区概念；而老年代对象基本不会动，GC几率较少，且都是大对象，用标记整理最合适。这样使整体GC效率提高

### 5、`类加载`

1. `流程`
    1. 类加载
    2. 类连接
    3. 类初始化
    4. ...
2. `类加载器`
    1. `Bootstrap加载器`----lib\rt.jar 包含了很多Jdk原有的类class文件
    2. `Extension加载器`----lib\ext\*.jar
    3. `App类加载器`----classpath
    4. `自定义加载器`----自定义加载类
3. `双亲委派模式加载`
    1. 主要是为了校验，不让编程者破坏jre运行环境
    2. 运用自定义类加载器可以实现热部署. [Java服务器热部署的实现原理](https://blog.csdn.net/xiaopihai86/article/details/50767628)

### `OOM问题`

1. 老年代被占满
2. 持久带被占满
3. 堆栈被占满
4. 线程堆栈被占满